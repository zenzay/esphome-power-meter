# Power Meter v0.9.1 Extended version
#
# Power Meter w/ Cost Tracking and Display.
#
# This version drops the led, adds a display and a push button
#
# ​ Sic biscuitus disintegratum ​

substitutions:
  pulse_rate: '1000.0'
  currency: 'DKK'
  pulse_pin: '26'
  button_pin: '25'
  ha_price_sensor: 'nordpool_kwh_dk2_dkk_4_095_025'
  update_interval: '60'
  flag_update_sensors: '1'
  flag_update_display: '2'
  flag_reset_hourly: '8'
  flag_reset_daily: '16'
  flag_reset_total: '128'
  flag_reset_mask: '248'

# substitutions:
#          pulse_rate: Pulse Rate of the LED on your power-panel-meter
#            currency: Currency in which to represent costs
#           pulse_pin: GPIO pin for the pulse_meter
#             led_pin: GPIO pin for the LED
#     ha_price_sensor: entity_id of the sensor used in Home Assistant to track spot prices.
#     update_interval: Seconds (ticks in 1s interval loop) between updating sensors.
#
# Note: The flag* substitutions are instead of #defines.

esphome:
  name: power-meter
  friendly_name: 'Power Meter'
  comment: 'Power Meter w/ Cost Tracking and Display'
  project:
    name: zenzay.power_meter
    version: '0.9.1'

preferences:
  flash_write_interval: 1h

esp32:
  board: nodemcu-32s
  framework:
    type: arduino

logger:

api:

ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password


# spi is used by the display
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23

font:
  - file:
      type: gfonts
      family: Roboto
      weight: 400
    id: my_tiny_font
    size: 10
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: my_small_font
    size: 13
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: my_medium_font
    size: 14
  - file:
      type: gfonts
      family: Roboto
      weight: 900
    id: my_big_font
    size: 20
    glyphs: ".,0123456789na"
  - file:
      type: gfonts
      family: Roboto
      weight: 900
    id: my_huge_font
    size: 48
    glyphs: ".,0123456789na"

image:
  - file: "pm_main.png"
    id: img_main
    type: TRANSPARENT_BINARY
  - file: "pm_graph.png"
    id: img_graph
    type: TRANSPARENT_BINARY
  - file: "pm_graph_now.png"
    id: img_graph_now
    type: TRANSPARENT_BINARY

globals:
  - id: usage_total         # total kwh usage
    type: float
    restore_value: yes
    initial_value: '0'

  - id: usage_day           # daily kwh usage
    type: float
    restore_value: yes
    initial_value: '0'

  - id: usage_hour          # hourly kwh usage
    type: float
    restore_value: no
    initial_value: '0'

  - id: cost_total          # total cost
    type: float
    restore_value: yes
    initial_value: '0'

  - id: cost_day            # daily cost
    type: float
    restore_value: yes
    initial_value: '0'

  - id: cost_hour           # hourly cost
    type: float
    restore_value: no
    initial_value: '0'

  - id: uptime_secs         # uptime second counter
    type: int
    restore_value: yes
    initial_value: '0'

  - id: cost_now            # hourly cost right now
    type: float
    restore_value: no
    initial_value: '0'

  - id: price_per_kwh       # price per kwh, should be automatically imported from HA, but can also be set manually
    type: float
    restore_value: no
    initial_value: '0'

  - id: uptime_start        # uptime start timestamp
    type: int
    restore_value: no
    initial_value: '0'

  - id: op_flag             # bitmask for setting operational flags (like reset total count).
    type: int
    restore_value: no
    initial_value: '0'

  - id: pulse_multiply      # pulse_meter state multiplier. it's set on boot or when user changes the Pulse Rate Number in HA.
    type: int               # really shouldn't use a global for this. But hey ho, waste some RAM, gain miniscule increase of execution speed, maybe.
    restore_value: no
    initial_value: '0'

  - id: usage_hour_list   # the hourly usage list. used to draw graphs and calculate stats
    type: float[24]
    restore_value: no
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'

  - id: cost_hour_list    # the hourly cost list. used to draw graphs and calculate stats
    type: float[24]
    restore_value: no
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'

number:
  - platform: template
    name: 'Set Pulse Rate'
    unit_of_measurement: 'Pulse/kWh'
    icon: mdi:pulse
    optimistic: true
    mode: box
    min_value: 100
    max_value: 10000
    step: 100
    initial_value: 1000
    entity_category: 'config'
    on_value:
      lambda: id(pulse_multiply) = (60.0f / x ) * 1000.0f;

  - platform: template
    name: 'Set Total Usage'
    unit_of_measurement: 'kWh'
    icon: mdi:meter-electric
    optimistic: true
    mode: box
    min_value: 0
    max_value: 100000
    step: 0.001
    initial_value: 0
    disabled_by_default: true
    entity_category: 'config'
    on_value:
      lambda: id(usage_total) = x;

  - platform: template
    name: 'Set Total Cost'
    unit_of_measurement: $currency
    icon: mdi:cash-100
    optimistic: true
    mode: box
    min_value: 0
    max_value: 100000
    step: 0.001
    initial_value: 0
    disabled_by_default: true
    entity_category: 'config'
    on_value:
      lambda: id(cost_total) = x;

  - platform: template
    name: 'Set Uptime'
    unit_of_measurement: 'days'
    icon: mdi:timelapse
    optimistic: true
    mode: box
    min_value: 0
    max_value: 365
    step: 0.01
    initial_value: 0
    disabled_by_default: true
    entity_category: 'config'
    on_value:
      lambda: |-
        id(uptime_start) = 0;
        id(uptime_secs) = ceil(x * 60.0f * 60.0f * 24.0f);

  - platform: template
    name: 'Set kWh Price'
    icon: mdi:cash-100
    unit_of_measurement: '${currency}/kWh'
    optimistic: true
    mode: box
    min_value: 0
    max_value: 100
    step: 0.001
    initial_value: 0
    disabled_by_default: true
    entity_category: 'config'
    on_value:
      lambda: id(price_per_kwh) = x;

  - platform: template
    id: power_problem_level
    name: 'Set Problem Level'
    icon: mdi:alert
    unit_of_measurement: 'W'
    optimistic: true
    mode: box
    min_value: 10
    max_value: 100000
    step: 1
    initial_value: 10000
    entity_category: 'config'

button:
  - platform: template
    name: 'Reset Totals'
    device_class: restart
    entity_category: 'config'
    on_press:
      lambda: id(op_flag) = $flag_reset_mask;

  - platform: shutdown
    name: 'Shutdown'

binary_sensor:
  - platform: template
    name: 'Power Status'
    id: power_status_sensor
    device_class: problem
    lambda: return ( id(power_pulse_meter).state >= id(power_problem_level).state);

  - platform: gpio
    id: display_page_button
    pin:
      number: $button_pin
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_on: 10ms
    on_release:
      then:
        - display.page.show_next: my_display
        - lambda: |-
            id(my_display).update();

sensor:
  - platform: homeassistant
    id: ha_price_per_kwh
    entity_id: 'sensor.${ha_price_sensor}'
    on_value:
      lambda: id(price_per_kwh) = x;

  - platform: pulse_meter
    name: 'Power Use'
    id: power_pulse_meter
    unit_of_measurement: 'W'
    state_class: measurement
    device_class: power
    icon: mdi:flash-outline
    accuracy_decimals: 0
    pin: $pulse_pin
    internal_filter_mode: EDGE
    internal_filter: 50ms
    filters:
      - lambda: return x * id(pulse_multiply);
    total:
      id: power_pulse_total
      on_value:
        script.execute: process_power_script

  - platform: template
    name: 'Usage Total'
    id: usage_total_sensor
    unit_of_measurement: 'kWh'
    icon: mdi:meter-electric
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    update_interval: never

  - platform: template
    name: 'Usage Daily'
    id: usage_day_sensor
    unit_of_measurement: 'kWh'
    icon: mdi:meter-electric
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    update_interval: never

  - platform: template
    name: 'Usage Hourly'
    id: usage_hour_sensor
    unit_of_measurement: 'kWh'
    icon: mdi:meter-electric
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    update_interval: never

  - platform: template
    name: 'Cost Now'
    id: cost_now_sensor
    icon: mdi:cash-fast
    accuracy_decimals: 3
    unit_of_measurement: '${currency}/h'
    device_class: monetary
    update_interval: never

  - platform: template
    name: 'Cost Total'
    icon: mdi:cash-100
    id: cost_total_sensor
    unit_of_measurement: $currency
    accuracy_decimals: 3
    device_class: monetary
    update_interval: never

  - platform: template
    name: 'Cost Daily'
    icon: mdi:cash-100
    id: cost_day_sensor
    unit_of_measurement: $currency
    accuracy_decimals: 3
    device_class: monetary
    update_interval: never

  - platform: template
    name: 'Cost Hourly'
    icon: mdi:cash-100
    id: cost_hour_sensor
    unit_of_measurement: $currency
    accuracy_decimals: 3
    device_class: monetary
    update_interval: never

  - platform: template
    name: 'Cost Daily Average'
    icon: mdi:cash-100
    id: cost_daily_avg_sensor
    accuracy_decimals: 3
    unit_of_measurement: $currency
    device_class: monetary
    update_interval: never

  - platform: template
    name: 'Usage Daily Average'
    icon: mdi:meter-electric
    id: usage_daily_avg_sensor
    accuracy_decimals: 3
    unit_of_measurement: 'kWh'
    device_class: energy
    update_interval: never

  - platform: template
    name: 'Uptime'
    icon: mdi:timelapse
    id: uptime_sensor
    accuracy_decimals: 2
    unit_of_measurement: 'days'
    update_interval: never

time:
  - platform: homeassistant
    id: esp_time

interval:
  - interval: 1s
    then:
      lambda: |-
        static uint32_t update_count = 0;         // count intervals between updates
        static uint32_t last_day_of_year = 0;     // day of the year the last time we reset daily
        static uint32_t last_hour_today = 0;      // hour today when we last reset hourly
        auto time = id(esp_time).now();           // getting the time
        if ( time.is_valid() ) {
          if ( time.day_of_year != last_day_of_year ) {
            if (last_day_of_year != 0) {
              id(op_flag) |= $flag_reset_daily;
            }
            last_day_of_year = time.day_of_year;
          }
          if ( time.hour != last_hour_today ) {
            if (last_hour_today != 0) {
              id(op_flag) |= $flag_reset_hourly;
            }
            last_hour_today = time.hour;
          }
        }
        if ( id(op_flag) & $flag_reset_total ) {
          id(uptime_start) = 0;
          id(uptime_secs) = 0;
          id(usage_total) = 0;
          id(cost_total) = 0;
          id(cost_now) = 0;
          update_count = 0;
        }
        if ( id(op_flag) & $flag_reset_daily ) {
          id(usage_day) = 0;
          id(cost_day) = 0;
          update_count = 0;
        }
        if ( id(op_flag) & $flag_reset_hourly ) {
          id(usage_hour) = 0;
          id(cost_hour) = 0;
          update_count = 0;
        }

        if ( time.is_valid() ) {
          if (update_count == 0) {
            id(op_flag) |= ($flag_update_sensors | $flag_update_display);
          }
          update_count++;
          if ( update_count >= $update_interval ) {
            update_count = 0;
          }
          if ( id(op_flag) & $flag_update_sensors ) {
            float days = 0;
            if ( id(uptime_start) == 0 ) {
              id(uptime_start) = time.timestamp - id(uptime_secs);
            }
            else if ( ( time.timestamp - id(uptime_start) ) > id(uptime_secs) ) {
              id(uptime_secs) = time.timestamp - id(uptime_start);
            }
            if ( id(uptime_secs) > 0 ) {
              days = id(uptime_secs) / 60.0f / 60.0f / 24.0f;
            }
            id(uptime_sensor).publish_state(days);
            if ( days < 1.0 ) { days = 1.0; }
            id(usage_daily_avg_sensor).publish_state(id(usage_total) / days);
            id(cost_daily_avg_sensor).publish_state(id(cost_total) / days);

            id(usage_total_sensor).publish_state(id(usage_total));
            id(cost_total_sensor).publish_state(id(cost_total));
            id(cost_now_sensor).publish_state(id(cost_now));

            id(usage_day_sensor).publish_state( id(usage_day) );
            id(cost_day_sensor).publish_state( id(cost_day) );
            id(usage_hour_sensor).publish_state( id(usage_hour) );
            id(cost_hour_sensor).publish_state( id(cost_hour) );
          }
          if ( id(op_flag) & $flag_update_display ) {
            // save hourly usage and cost
            id(usage_hour_list)[time.hour] = id(usage_hour);
            id(cost_hour_list)[time.hour] = id(cost_hour);
            id(my_display).update();
          }
        }
        id(op_flag) = 0;         // making sure the flag operations are one-shot

# Draw stuff on the display. push button to change page
# Page 1 is a status page
# Page 2 a time graph over daily usage
# Page 3 a time graph over daily cost
display:
  - platform: waveshare_epaper
    cs_pin: GPIO5
    dc_pin: GPIO17
    busy_pin: GPIO19
    reset_pin: GPIO16
    model: 2.90in  #296x128
    rotation: 90
    id: my_display
    full_update_every: 60
    auto_clear_enabled: false
    update_interval: never
    pages:
      - id: page1
        lambda: |-
          const int col_size = it.get_width() / 8;
          const int row_size = it.get_height() / 32;
          it.fill(COLOR_OFF);
          it.image(0, 0, id(img_main));
          it.printf(col_size * 2, row_size * 9, id(my_huge_font), TextAlign::CENTER, "%.0f", id(power_pulse_meter).state);
          it.printf(col_size * 6 - 8, row_size * 4, id(my_medium_font), TextAlign::TOP_LEFT, "%s", id(power_status_sensor).state ? "Problem!" : "OK");
          it.printf(col_size * 6 - 8, row_size * 8, id(my_medium_font), TextAlign::TOP_LEFT, "%.2f days", id(uptime_secs) / 60.0f / 60.0f / 24.0f);
          it.strftime(col_size * 6, row_size * 16 - 1, id(my_medium_font), TextAlign::CENTER, "%Y-%m-%d  %H:%M", id(esp_time).now());
          it.printf(col_size, row_size * 25, id(my_big_font), TextAlign::CENTER, "%.2f", id(price_per_kwh));
          it.printf(col_size * 3, row_size * 25, id(my_big_font), TextAlign::CENTER, "%.2f", id(cost_now));
          it.printf(col_size * 5, row_size * 25, id(my_big_font), TextAlign::CENTER, "%.2f", id(usage_total));
          it.printf(col_size * 7, row_size * 25, id(my_big_font), TextAlign::CENTER, "%.2f", id(cost_total));
          it.print(col_size * 2, row_size * 16, id(my_tiny_font), TextAlign::CENTER,  "WATT");
          it.print(col_size, row_size * 30, id(my_tiny_font), TextAlign::CENTER, "${currency} / kWh");
          it.print(col_size * 3, row_size * 30, id(my_tiny_font), TextAlign::CENTER, "${currency}/h");
          it.print(col_size * 5, row_size * 30, id(my_tiny_font), TextAlign::CENTER, "kWh");
          it.print(col_size * 7, row_size * 30, id(my_tiny_font), TextAlign::CENTER, "${currency}");

      - id: page_2
        lambda: |-
          const int GR_HEIGHT = 59;
          const int GR_COL_SIZE = 7;
          const int GR_BOTTOM = 99;
          const int GR_LEFT = 42;
          const int GR_NOW_OFFSET = 10;
          auto time = id(esp_time).now();
          int i = 0;
          int size = 0;
          int x = time.hour * GR_COL_SIZE + (time.minute / 60.0f) * (GR_COL_SIZE-2) + GR_LEFT - GR_NOW_OFFSET;
          float val = 0;
          float min = 1000;
          float max = 0;
          float sum = 0;
          float avg = 0;
          it.fill(COLOR_OFF);
          it.image(0, 0, id(img_graph));
          it.print(20, -1, id(my_medium_font), TextAlign::LEFT, "Usage Today - kWh" );
          it.image(x, 22, id(img_graph_now));

          // We have to decided whether to include the current hour. We'll have to get the definite max to draw the chart but
          // including the current hour while finding the minimum value will mean that a new hour rolling by probably will have the new minimum
          // also the average should probably not include the current hour, as that again will lower it at new hour
          // so always count max but only include the current hour with min and sum, IF minutes past 30?
          // or just always include current hour?
          for (i=0; i<=time.hour; i++) {
            val = id(usage_hour_list)[i];
            sum += val;
            if (val > max) {
              max = val;
            }
            if (val < min) {
              min = val;
            }
          }

          if (max < 0.1) { max = 0.1; }
          size = floor(GR_HEIGHT / max);
          avg = sum / (time.hour + 1);

          it.printf(GR_LEFT-8, 33, id(my_tiny_font), TextAlign::RIGHT, "%.2f", max);
          it.printf(GR_LEFT-8, 63, id(my_tiny_font), TextAlign::RIGHT, "%.2f", max / 2);
          it.printf(274, 23, id(my_small_font), TextAlign::CENTER, "%.2f", id(usage_hour));
          it.printf(274, 45, id(my_small_font), TextAlign::CENTER, "%.2f", min);
          it.printf(274, 68, id(my_small_font), TextAlign::CENTER, "%.2f", max);
          it.printf(274, 91, id(my_small_font), TextAlign::CENTER, "%.2f", avg);
          it.printf(274, 114, id(my_small_font), TextAlign::CENTER, "%.2f", sum);
          for (i=0; i<=time.hour; i++) {
            val = ceil(id(usage_hour_list)[i] * size);
            if (val > 0) {
              if (val < 1) { val = 1; }
              x = i * GR_COL_SIZE + GR_LEFT;
              it.filled_rectangle(x, GR_BOTTOM - val, GR_COL_SIZE-2, val);
            }
          }

      - id: page_3
        lambda: |-
          const int GR_HEIGHT = 59;
          const int GR_COL_SIZE = 7;
          const int GR_BOTTOM = 99;
          const int GR_LEFT = 42;
          const int GR_NOW_OFFSET = 10;
          auto time = id(esp_time).now();
          int i = 0;
          int size = 0;
          int x = time.hour * GR_COL_SIZE + (time.minute / 60.0f) * (GR_COL_SIZE-2) + GR_LEFT - GR_NOW_OFFSET;
          float val = 0;
          float min = 1000;
          float max = 0;
          float sum = 0;
          float avg = 0;
          it.fill(COLOR_OFF);
          it.image(0, 0, id(img_graph));
          it.print(20, -1, id(my_medium_font), TextAlign::LEFT, "Cost Today - ${currency}" );
          it.image(x, 22, id(img_graph_now));
          for (i=0; i <= time.hour; i++) {
            val = id(cost_hour_list)[i];
            sum += val;
            if (val > max) {
              max = val;
            }
            if (val < min) {
              min = val;
            }
          }
          if (max < 0.1) { max = 0.1; }
          size = floor(GR_HEIGHT / max);
          avg = sum / (time.hour + 1);
          it.printf(GR_LEFT-8, 33, id(my_tiny_font), TextAlign::RIGHT, "%.2f", max);
          it.printf(GR_LEFT-8, 63, id(my_tiny_font), TextAlign::RIGHT, "%.2f", max / 2);
          it.printf(274, 23, id(my_small_font), TextAlign::CENTER, "%.2f", id(cost_hour));
          it.printf(274, 45, id(my_small_font), TextAlign::CENTER, "%.2f", min);
          it.printf(274, 68, id(my_small_font), TextAlign::CENTER, "%.2f", max);
          it.printf(274, 91, id(my_small_font), TextAlign::CENTER, "%.2f", avg);
          it.printf(274, 114, id(my_small_font), TextAlign::CENTER, "%.2f", sum);
          for (i=0; i<=time.hour; i++) {
            val = ceil(id(cost_hour_list)[i] * size);
            if (val > 0) {
              if (val < 1) { val = 1; }
              x = i * GR_COL_SIZE + GR_LEFT;
              it.filled_rectangle(x, GR_BOTTOM - val, GR_COL_SIZE-2, val);
            }
          }

script:
  - id: process_power_script
    mode: single
    then:
      - lambda: |-
          static uint32_t last_pulse_ms = 0;
          const uint32_t now = millis();
          if (last_pulse_ms == 0) {
            last_pulse_ms = now;
            return;
          }
          const float delta_hours = (now - last_pulse_ms) / 1000.0f / 60.0f / 60.0f;
          last_pulse_ms = now;    // remember last pulse milliseconds
          float new_state = id(power_pulse_meter).state / 1000.0f;
          const float energy = delta_hours * new_state;
          const float cost = energy * id(price_per_kwh);
          id(usage_total) += energy;
          id(usage_day) += energy;
          id(usage_hour) += energy;
          id(cost_total) += cost;
          id(cost_day) += cost;
          id(cost_hour) += cost;
          id(cost_now) = new_state * id(price_per_kwh);
          id(usage_total_sensor).publish_state(id(usage_total));
          id(cost_total_sensor).publish_state(id(cost_total));
          id(cost_now_sensor).publish_state(id(cost_now));
      - if:
          condition:
            display.is_displaying_page: page1
          then:
            lambda: id(op_flag) |= $flag_update_display;
